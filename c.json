{
	"LLibsMain":{
		"prefix": "LLMAIN",
		"body": [
			"#include <stdio.h>\t// Includo la libreria per la funzione printf e BUFSIZ",
			"#include <stdlib.h>\t// Includo la libreria per la funzione exit",
			"#include <unistd.h>\t// Includo la libreria per la funzione close, fork, exec, read, write",
			"#include <fcntl.h>\t// Includo la libreria per la funzione open e le relative macro",
			"#include <sys/wait.h>\t// Includo la libreria per la funzione wait\n\n",

			
			"int main(int argc, char** argv) {",
				"\t$0\n",
				"\texit(0);",
			"}"
		],
		"description": "Generates Main and needed libs LL Style"
	},

	"check.open":{
		"prefix": [
			"open",
			"if is file"
		],
		"body": [
			"//controllo se il file e' accedibile",
			"int fd = 0; /*variabile che conterra il file descriptor del file che stiamo per aprire */",
			"if((fd = open(${1:file}, ${3|O_RDONLY,O_WRONLY,O_RDWR|})) < 0){\t\t/* ERRORE se non si riesce ad aprire in LETTURA il file */", 
				"\tprintf(\"Errore in apertura file %s dato che fd = %d\\n\", ${1:file}, fd);",
				"\texit(${2:ExitValue});",
			"}$0"
		],
		"description": "Opens a file in the selected mode and checks if the action is successful"
	},

	"check.creat":{
		"prefix": [
			"creat"
		],
		"body": [
			"//creo il file",
			"int fd = 0; /*variabile che conterra il file descriptor del file che stiamo per creare */",
			"if((fd = creat(${1:file}, ${2:0640})) < 0){\t\t/* ERRORE se non si riesce a creare il file */", 
				"\tprintf(\"Errore in creazione del file %s dato che fd = %d\\n\", ${1:file}, fd);",
				"\texit(${3:ExitValue});",
			"}$0"
		],
		"description": "Opens a file in the selected mode and checks if the action is successful"
	},

	"check.singleChar":{
		"prefix": "if single char",
		"body": [
			"//controlla che la stringa <StringaSorgente> sia un singolo carattere",
			"if (strlen(${1:StringaSorgente}) != 1) {\t// #include <string.h>",
				"\tprintf(\"Errore, la stringa %s non e' un singolo carattere\\n\", ${1:StringaSorgente});",
				"\texit(${3:ErrorCode});",
			"}",
			"char ${2:Cx} = ${1:StringaSorgente}[0];"
		],
		"description": "Check if the specified string is a single char then assign it to a char variable"
	},

	"check.params_LessEqual":{
		"prefix": "if params <=",
		"body": [
			"if (argc > ${1:NParams} + 1) /* controllo sul numero di parametri: devono essere in numero minore o uguale a ${1:NParams}*/",
        	"{",
				"\tprintf(\"Errore: numero di argomenti sbagliato dato che argc = %d\\n\", argc);",
        		"\texit(${3:ExitValue});",
			"}$0"
		],
		"description": "Checks if the number of parameters passed is less or equal than the specified number"
	},

	"check.params_Less":{
		"prefix": "if params <",
		"body": [
			"if (argc >= ${1:NParams} + 1) /* controllo sul numero di parametri: devono essere in numero minore a ${1:NParams}*/",
        	"{",
				"\tprintf(\"Errore: numero di argomenti sbagliato dato che argc = %d\\n\", argc);",
				"\texit(${3:ExitValue});",
			"}$0"
		],
		"description": "Checks if the number of parameters passed is less than the specified number"
	},

	"check.params_GreaterEqual":{
		"prefix": "if params >=",
		"body": [
			"if (argc < ${1:NParams} + 1) /* controllo sul numero di parametri: devono essere in numero maggiore o uguale a ${1:NParams}*/",
        	"{",
				"\tprintf(\"Errore: numero di argomenti sbagliato dato che argc = %d\\n\", argc);",
				"\texit(${3:ExitValue});",
			"}$0"
		],
		"description": "Checks if the number of parameters passed is greater or equal than the specified number"
	},

	"check.params_Greater":{
		"prefix": "if params >",
		"body": [
			"if (argc <= ${1:NParams} + 1) /* controllo sul numero di parametri: devono essere in numero maggiore a ${1:NParams}*/",
			"{",
				"\tprintf(\"Errore: numero di argomenti sbagliato dato che argc = %d\\n\", argc);",
				"\texit(${3:ExitValue});",
			"}$0"
		],
		"description": "Checks if the number of parameters passed is greater than the specified number"
	},

	"check.params_Equals":{
		"prefix": "if params ==",
		"body": [
			"if (argc != ${1:NParams} + 1) /* controllo sul numero di parametri: devono essere in numero uguale a ${1:NParams}*/",
        	"{",
				"\tprintf(\"Errore: numero di argomenti sbagliato dato che argc = %d\\n\", argc);",
				"\texit(${3:ExitValue});",
			"}$0"
		],
		"description": "Checks if the number of parameters passed equals the specified number"
	},

	"check.params_InRange":{
		"prefix": "if params range",
		"body": [
			"if (argc < ${1:lower bound} + 1 || argc > ${2:upper bound} + 1) /* controllo sul numero di parametri: devono essere compresi tra ${1:lower bound} e ${2:upper bound} */",
        	"{",
				"\tprintf(\"Errore: numero di argomenti sbagliato dato che argc = %d\\n\", argc);",
				"\texit(${5:ExitValue});",
			"}$0"
		],
		"description": "Checks if the number of parameters passed is in the specified range"
	},

	"check.Is_PosNumber":{
		"prefix": "if Strict Positive Number",
		"body": [
			"int ${1:Variabile};\t\t/*Inizializzo varibile che conterra' ${2:Param}*/",
			"//controllo utlizzando la funzione atoi se il ${2:Param} e un numero strettamente positivo",
			"if((${1:Variabile} = atoi(${2:Param})) <= 0){",
				"\tprintf(\"il parametro %s non un numero positivo\\n\",${2:Param});",
				"\texit(${3:ExitValue});",
			"}$0"
			],
			"description": "Checks if the specified parameter is a positive number"
	},

	"file.ReadWithBuffer":{
		"prefix": "read buffers from file",
		"body": [
			"char ${1:buffer}[BUFSIZ];    // buffer che verra' letto da file",
			"int ${2:nread};              // variabile che memorizzera' il ritorno della read\n",

			"while ((${2:nread} = read(${3:infile}, ${1:buffer}, BUFSIZ)) > 0 )\t/* ciclo di lettura fino a che nread e' maggiore di 0 */",
			"{",
				"\t$0",
			"}"
		],
		"description": "Read from file BUFSIZ bytes each time"
	},

	"file.ReadCharByChar":{
		"prefix": "read chars from file",
		"body": [
			"char ${1:buffer};\n",

			"while (read(${2:infile}, &${1:buffer}, 1) > 0)\t/* ciclo di lettura fino a che riesco a leggere un carattere da file */",
			"{",
				"\t$0",
			"}"
		],
		"description": "Read from file one byte each time"
	},

	"util.ErrorPrint":{
		"prefix": "printf error",
		"body": [
			"printf(\"Errore, ${1:error text}\\n\"); ",
			"exit(${2:ExitValue});$0",
		],
		"description": "Classical error print and exit"
	},

	"util.perror":{
		"prefix": "perror",
		"body": [
			"perror(\"Errore, ${1:error text}\\n\"); ",
			"exit(errno);\t// #include <errno.h>",
			"$0"
		],
		"description": "Classical error print and exit"
	},

	"process.fork":{
		"prefix": "fork",
		"body": [
			"int ${1:pidChild};\t// memorizzo il valore di ritorno della funzione fork\n",
			"if ((${1:pidChild} = fork()) < 0)\t/* Il processo padre crea un figlio */",
			"{\t/* In questo caso la fork e' fallita */",
			"\tprintf(\"Errore durante la fork\\n\");",
			"\texit(${2:ErrorCode});",
			"}\n",
			"if (${1:pidChild} == 0)",
			"{\t/* processo figlio */",
			"\t$3",
			"\texit(${4:0});",
			"}",
			"/* processo padre */",
			"$0",
		],
		"description": "Fork a process following the correcto generation scheme"
	},

	"process.exec": {
		"prefix": "exec",
		"body": [
			"${1|execv,execl,execvp,execlp|}(${2:params}); // in caso di lista, ricordati di 0 terminare la lista dei parametri!",
			"/* si esegue l'istruzione seguente SOLO in caso di fallimento */\n",
			"perror(\"${3:errore esecuzione comando}\"); // #include <errno.h>",
			"exit(errno);"
		]
	},

	"process.wait_IgnoreReturn":{
		"prefix": "wait ignore return",
		"body": [
			"int ${2:pidChild};",
			"if (${2:pidChild} = wait((int*) 0) < 0) {",
				"\tprintf(\"Non e' stato creato nessun processo figlio\\n\");",
				"\texit(${1:ErrorCode});",
			"}$0",
		],
		"description": "wait the termination of one child process ignoring the return value of the child"
	},

	"process.wait_StoreReturn":{
		"prefix": "wait store return",
		"body": [
			"int ${2:pidChild};",
			"int ${1:status};\t// La variabile usata per memorizzare quanto ritornato dalla primitiva wait",
			"int ${3:ritorno};\t// La variabile usata per memorizzare il valore di ritorno del processo figlio",
			"if ((${2:pidChild} = wait(&${1:status})) < 0) {",
				"\tprintf(\"Non e' stato creato nessun processo figlio\\n\");",
				"\texit(${4:ErrorCode});",
			"}\n",

			"if ((${1:status} & 0xFF) != 0)",
			"{",
				"\tprintf(\"Il processo figlio Ã¨ stato terminato in modo anomalo\\n\");",
				"\texit(${4:ErrorCode});",
			"} else {",
				"\t${3:ritorno} = (${1:status} >> 8) & 0xFF;",
				"$0",
			"}",
		],
		"description": "wait the termination of one child process ignoring the return value of the child"
	},

	"util.DebugPrint":{
		"prefix": "printf debug",
		"body": "printf(\"DEBUG:${1:debug print}\\n\"$2);",
		"description": "standard debug print"
	},

	"util.FiglioPrint":{
		"prefix": "printf figlio",
		"body": "printf(\"il figlio pid=%i ed ha ritornato=%i\\n\",${1:pidFiglio},${2:ritorno});",
		"description": "standard print to display return value and pid of a child"
	},

	"pipes.typedef":{
		"prefix": "LLTYPEDEF",
		"body": ["//definisco il tipo pipe_t",
				 "typedef int pipe_t[2];"],
		"description": "definisce un array di pipe LLStyle"
	},

	"pipes.forAperturaNPipe":{
			"prefix": "for apertura N pipe",
			"body": ["//apro $2 pipes",
					"pipe_t* piped=malloc(sizeof(pipe_t)*(${2:Fasi}));",
					"for(int i=0;i<${2:Fasi};i++){",
					"\tif(pipe(piped[i])<0){",
					"\t\tprintf(\"Errore nella creazione della pipe numero:%i\",i);",
					"\t\texit(${3:ExitValue});",
					"\t}","}"],
			"description": "apre N pipe"	
	},

	"pipes.forChiusuraLatoPipe":{
		"prefix": "for chiusura n lati pipes",
		"body": [
			"//chiudo tutte le pipe in lettura e scrittura tranne la $3-esima pipe, aperta in ${6|scrittura, lettura|}",
			"for(int ${1:k} = 0; $1 < ${2:N}; $1++){",
			"\tclose(piped[$1][${4|1,0|}]);",
			"\tif ($1 != ${3:i}) {",
			"\t\tclose(piped[$1][${5|0,1|}]);",
			"\t}",
			"}",
			],
		"description": "chiude n pipe"
	},
	"pipes.dup":{
		"prefix": "dup ridirezione",
		"body": ["//chiudo lo ${1|stdin,stdout|}",
				"close(${2|0,1|});",
				"//duplico la pipe lato ${3|scrittura,lettura|}",
				"dup(piped$4);",
				"//chiudo il lato della pipe duplicato",
				"close(piped$4);",
				"$0",
			],
		"description": "chiude lo stdout/stdin ed lo rimpiazza con la pipe in lettura/scrittura"
	},

	"pipes.creaPipeSingola":{
		"prefix": "pipe singola",
		"body": [
			"pipe_t ${1:piped};",
			"",
			"if (pipe(${1:piped}) < 0 )",
			"{\tprintf(\"Errore creazione pipe\\n\");",
			"\texit(${2:ErrorCode});",
			"}",
		],
		"description": "Crea una singola pipe e controlla che sia stata creata correttamente"
	}
	
	
}